import { Meta } from "@storybook/addon-docs";
import { Sandpack } from "@codesandbox/sandpack-react";

<Meta title="Getting Started" />

---

# Getting Started

You can use the components anywhere you use HTML, either natively (see
[Using a CDN](#using_a_cdn) or [Using modules](#using_modules)), or with a library
like React (see [Using a library or framework](#usage_with_popular_libraries_and_frameworks)).

## Using a CDN

All the components are compiled down to ES2020 before being distributed via
[jsDelivr](https://jsdelivr.com). In order to resolve imports modules use an
[import map](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap).

### Polyfills

If you are not using a modern browser you may have to use a [polyfill](https://github.com/guybedford/es-module-shims)
for the import maps.

### Displaying your first component

For this example we will display the `nightingale-sequence` component. Firstly we must create an
[import map](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap)
to resolve es-module imports. After this we can import `nightingale-sequence` within a `<script type="module">`.
After these steps we can use the component just like you would a regular HTML tag. Complete example below:

<Sandpack
  template="static"
  files={{
    "index.html": `<!-- Firstly create an importmap to resolve module imports -->
  <script type="importmap">
  {
    "imports": {
      "@nightingale-elements/": "https://cdn.jsdelivr.net/npm/@nightingale-elements/"
    }
  }
</script>
<!-- Import the component -->
<script type="module">
  import "@nightingale-elements/nightingale-sequence@latest";
</script>
<!-- Use the component just as you would a regular HTML tag -->
<nightingale-sequence
  sequence="SEQUENCESEQUENCESEQUENCESEQUENCE"
  width="800"
  height="40"
  length="32"
  display-start="10"
  display-end="20"
  highlight="3:15"
  id="my-nightingale-sequence-id"
></nightingale-sequence>
`,
  }}
/>

### Setting the sequence property

As well as setting the sequence as an attribute of the `nightingale-sequence`,
it's also possible to load this as a property as seen in the following code snippet:

<Sandpack
  template="static"
  files={{
    "index.html": `<!-- Firstly create an importmap to resolve module imports -->
  <script type="importmap">
  {
    "imports": {
      "@nightingale-elements/": "https://cdn.jsdelivr.net/npm/@nightingale-elements/"
    }
  }
</script>
<!-- Import the component -->
<script type="module">
  import "@nightingale-elements/nightingale-sequence@latest";
</script>
<script>
  // Once the element is defined, set the sequence data
  customElements.whenDefined("nightingale-sequence").then(() => {
    const seq = document.querySelector("#my-nightingale-sequence-id");
    seq.data = "SEQUENCESEQUENCESEQUENCESEQUENCE";
  })
</script>
<!-- Use the component just as you would a regular HTML tag -->
<nightingale-sequence
  width="800"
  height="40"
  length="32"
  display-start="10"
  display-end="20"
  highlight="3:15"
  id="my-nightingale-sequence-id"
></nightingale-sequence>`,
  }}
/>

## Usage with popular libraries and frameworks

Since this project relies on a web standard, namely
[custom-elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements),
its use should be made easier and cross-library bugs and unwanted interactions should be reduced significantly.

Depending on the library or framework you are using, you might want to consider
[having a look here](https://custom-elements-everywhere.com/) to check possible
pitfalls and consider workarounds.

### React

If you decide to use your own data loaders, the recommended way is to use `ref`s
so you can then use the component's API to deal with asynchronicity:

<Sandpack
  template="react"
  customSetup={{
    dependencies: {
      "@nightingale-elements/nightingale-sequence": "latest",
    },
  }}
  files={{
    "/App.js": `import { useEffect, useRef } from "react";
import "@nightingale-elements/nightingale-sequence";
 
export default function App() {
 
const seqContainer = useRef(null);
  
  const data = "SEQUENCESEQUENCESEQUENCESEQUENCE";
  
  useEffect(()=> {
    if(seqContainer) {
      seqContainer.current.data = data;
    }
  }, [data]);
   
  return <nightingale-sequence
    ref={seqContainer}
    width="800"
    height="40"
    length="32"
    display-start="10"
    display-end="20"
    highlight="3:15"
  ></nightingale-sequence>;
}`,
  }}
/>

Or you can decided to use a helper component that would bridge the gap between
the React way of doing things and the standard Custom Element's:

- [`<ReactPropertySetter />` to set properties on elements (instead of just the attribute as React does)](https://www.npmjs.com/package/react-property-setter)
- [`<ReactEventEmitter />` to emit events from data in React](https://www.npmjs.com/package/react-event-emitter)

## Bundling workflow

All components are exported as modules. This means you can import them like any
other ES6 module in your application:

```js
import NightingaleSequence from "@nightingale-elements/nightingale-sequence";
```
